<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>爸爸的开心消消乐</title>
  <style>
    :root {
      --bg-1: #0b1320;
      --bg-2: #1b2a44;
      --panel: rgba(12, 18, 32, 0.92);
      --panel-line: rgba(255, 255, 255, 0.12);
      --text: #eef4ff;
      --muted: #9fb0c9;
      --accent: #ffd77a;
      --tile: min(12.5vw, 64px);
      --gap: 7px;
      --radius: 14px;
      --shadow: 0 18px 36px rgba(5, 8, 16, 0.55);
      --board-grad: linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Noto Sans SC", "PingFang SC", "Microsoft YaHei", system-ui, sans-serif;
      color: var(--text);
      min-height: 100vh;
      background:
        radial-gradient(60vmax 48vmax at 20% -10%, rgba(255, 225, 165, 0.14), transparent 60%),
        radial-gradient(50vmax 45vmax at 85% 100%, rgba(125, 170, 255, 0.2), transparent 65%),
        linear-gradient(180deg, var(--bg-2), var(--bg-1));
      display: grid;
      place-items: center;
      padding: 18px;
    }

    .app {
      width: min(960px, 100%);
      display: grid;
      gap: 16px;
    }

    .header {
      display: grid;
      gap: 8px;
      text-align: center;
    }

    .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .back {
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #e7eeff;
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 12px;
      text-decoration: none;
      white-space: nowrap;
    }

    h1 {
      margin: 0;
      font-size: clamp(20px, 3.8vw, 30px);
      letter-spacing: 1px;
    }

    .subtitle {
      color: var(--muted);
      font-size: clamp(12px, 2.6vw, 14px);
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--panel-line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 14px;
      backdrop-filter: blur(8px);
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      text-align: center;
    }

    .stat {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 10px 6px;
      background: rgba(255,255,255,0.04);
    }

    .stat h3 {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
      font-weight: 500;
    }

    .stat p {
      margin: 4px 0 0;
      font-size: clamp(18px, 4vw, 24px);
      font-weight: 700;
    }

    .board-wrap {
      display: grid;
      gap: 12px;
    }

    .board {
      width: calc(8 * var(--tile) + 7 * var(--gap) + 20px);
      max-width: 100%;
      margin: 0 auto;
      padding: 10px;
      border-radius: 18px;
      background: var(--board-grad);
      border: 1px solid rgba(255,255,255,0.08);
      display: grid;
      grid-template-columns: repeat(8, var(--tile));
      gap: var(--gap);
      justify-content: center;
      touch-action: none;
    }

    .tile {
      width: var(--tile);
      height: var(--tile);
      border-radius: var(--radius);
      display: grid;
      place-items: center;
      font-size: clamp(18px, 4.3vw, 22px);
      font-weight: 700;
      color: rgba(255, 255, 255, 0.9);
      box-shadow: inset 0 2px 6px rgba(255,255,255,0.18), 0 6px 12px rgba(0,0,0,0.25);
      transition: transform 0.16s ease, filter 0.16s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .tile.selected {
      transform: scale(1.08);
      filter: brightness(1.15);
      outline: 2px solid rgba(255, 255, 255, 0.6);
      outline-offset: -2px;
    }

    .tile.match {
      animation: pop 0.24s ease;
    }

    @keyframes pop {
      0% { transform: scale(1); }
      40% { transform: scale(1.15); }
      100% { transform: scale(0.9); opacity: 0.6; }
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .settings {
      display: grid;
      gap: 8px;
      margin-bottom: 10px;
    }

    .settings label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    select {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      padding: 8px 10px;
      font-size: 14px;
    }

    button {
      width: 100%;
      border: none;
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      background: linear-gradient(160deg, #ffd77a, #ffb95f);
      color: #1b1b1b;
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.28);
    }

    button.secondary {
      background: linear-gradient(160deg, #4a638f, #2f3e5f);
      color: #e7eeff;
    }

    button.ghost {
      background: rgba(255,255,255,0.08);
      color: #dce6ff;
      border: 1px solid rgba(255,255,255,0.12);
    }

    .message {
      text-align: center;
      color: var(--accent);
      font-weight: 700;
      min-height: 24px;
    }

    .tips {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
      text-align: center;
    }

    @media (max-width: 720px) {
      :root { --gap: 6px; --tile: min(13.5vw, 66px); }
      .controls { grid-template-columns: 1fr; }
      .stats { grid-template-columns: repeat(2, 1fr); }
      .stat:last-child { grid-column: span 2; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="header-row">
        <a class="back" href="../">返回合集</a>
        <div style="width: 84px;"></div>
      </div>
      <h1>爸爸的开心消消乐</h1>
      <div class="subtitle">轻松消除，快乐每一天</div>
    </div>

    <div class="panel">
      <div class="stats">
        <div class="stat">
          <h3>得分</h3>
          <p id="score">0</p>
        </div>
        <div class="stat">
          <h3>剩余步数</h3>
          <p id="moves">20</p>
        </div>
        <div class="stat">
          <h3>目标分数</h3>
          <p id="target">1200</p>
        </div>
      </div>
    </div>

    <div class="panel board-wrap">
      <div id="message" class="message"></div>
      <div id="board" class="board" aria-label="开心消消乐棋盘"></div>
    </div>

    <div class="panel">
      <div class="settings">
        <div>
          <label for="difficulty">难度</label>
          <select id="difficulty">
            <option value="easy">简单</option>
            <option value="normal" selected>普通</option>
            <option value="hard">困难</option>
            <option value="master">大师</option>
            <option value="hell">地狱</option>
            <option value="extreme">极限</option>
          </select>
        </div>
      </div>
      <div class="controls">
        <button id="restart">重新开始</button>
        <button id="shuffle" class="secondary">洗牌</button>
        <button id="help" class="ghost">玩法说明</button>
      </div>
    </div>

    <div class="tips" id="tips">
      点击或拖动两个相邻的方块进行交换，连成三个或更多同色即可消除。
    </div>
  </div>

  <script>
    const rows = 8;
    const cols = 8;
    const colors = [
      { name: "sun", label: "★", bg: "linear-gradient(145deg, #ffd56a, #ffb85c)" },
      { name: "sky", label: "◆", bg: "linear-gradient(145deg, #7fd2ff, #5aa9ff)" },
      { name: "rose", label: "❤", bg: "linear-gradient(145deg, #ff8eb3, #ff6a88)" },
      { name: "mint", label: "●", bg: "linear-gradient(145deg, #8ff0b5, #4bdc92)" },
      { name: "grape", label: "▲", bg: "linear-gradient(145deg, #c3a5ff, #8b6bff)" },
      { name: "amber", label: "✦", bg: "linear-gradient(145deg, #ffc37b, #ff8f4f)" }
    ];

    const boardEl = document.getElementById("board");
    const scoreEl = document.getElementById("score");
    const movesEl = document.getElementById("moves");
    const targetEl = document.getElementById("target");
    const messageEl = document.getElementById("message");
    const tipsEl = document.getElementById("tips");

    let board = [];
    let selected = null;
    let score = 0;
    let moves = 20;
    let target = 1200;
    let busy = false;
    let pointerId = null;
    let dragStart = null;
    let swapTriggered = false;
    let paletteSize = colors.length;

    function randColor() {
      return Math.floor(Math.random() * paletteSize);
    }

    function applyDifficulty() {
      const level = document.getElementById("difficulty").value;
      if (level === "easy") {
        moves = 28;
        target = 900;
        paletteSize = 4;
      } else if (level === "normal") {
        moves = 22;
        target = 1200;
        paletteSize = 5;
      } else if (level === "hard") {
        moves = 18;
        target = 1500;
        paletteSize = 6;
      } else if (level === "master") {
        moves = 16;
        target = 1800;
        paletteSize = 6;
      } else if (level === "hell") {
        moves = 14;
        target = 2100;
        paletteSize = 6;
      } else {
        moves = 12;
        target = 2500;
        paletteSize = 6;
      }
    }

    function createEmptyBoard() {
      return Array.from({ length: rows }, () => Array(cols).fill(null));
    }

    function hasMatchAt(r, c, color) {
      let count = 1;
      let i = c - 1;
      while (i >= 0 && board[r][i] === color) { count++; i--; }
      i = c + 1;
      while (i < cols && board[r][i] === color) { count++; i++; }
      if (count >= 3) return true;

      count = 1;
      let j = r - 1;
      while (j >= 0 && board[j][c] === color) { count++; j--; }
      j = r + 1;
      while (j < rows && board[j][c] === color) { count++; j++; }
      return count >= 3;
    }

    function fillBoard() {
      board = createEmptyBoard();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          let color;
          do {
            color = randColor();
          } while (hasMatchAt(r, c, color));
          board[r][c] = color;
        }
      }
    }

    function renderBoard() {
      boardEl.innerHTML = "";
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.dataset.row = r;
          tile.dataset.col = c;
          const color = colors[board[r][c]];
          tile.style.background = color.bg;
          tile.textContent = color.label;
          boardEl.appendChild(tile);
        }
      }
    }

    function updateStats() {
      scoreEl.textContent = score;
      movesEl.textContent = moves;
      targetEl.textContent = target;
    }

    function setMessage(text) {
      messageEl.textContent = text || "";
    }

    function clearSelection() {
      if (!selected) return;
      const tile = getTileEl(selected.r, selected.c);
      if (tile) tile.classList.remove("selected");
      selected = null;
    }

    function getTileEl(r, c) {
      return boardEl.querySelector(`[data-row="${r}"][data-col="${c}"]`);
    }

    function isAdjacent(a, b) {
      return Math.abs(a.r - b.r) + Math.abs(a.c - b.c) === 1;
    }

    function swap(a, b) {
      const temp = board[a.r][a.c];
      board[a.r][a.c] = board[b.r][b.c];
      board[b.r][b.c] = temp;
    }

    function findMatches() {
      const matches = Array.from({ length: rows }, () => Array(cols).fill(false));
      let found = false;

      for (let r = 0; r < rows; r++) {
        let streak = 1;
        for (let c = 1; c <= cols; c++) {
          if (c < cols && board[r][c] === board[r][c - 1]) {
            streak++;
          } else {
            if (streak >= 3) {
              found = true;
              for (let k = 0; k < streak; k++) {
                matches[r][c - 1 - k] = true;
              }
            }
            streak = 1;
          }
        }
      }

      for (let c = 0; c < cols; c++) {
        let streak = 1;
        for (let r = 1; r <= rows; r++) {
          if (r < rows && board[r][c] === board[r - 1][c]) {
            streak++;
          } else {
            if (streak >= 3) {
              found = true;
              for (let k = 0; k < streak; k++) {
                matches[r - 1 - k][c] = true;
              }
            }
            streak = 1;
          }
        }
      }

      return { matches, found };
    }

    function applyMatches(matches) {
      let cleared = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (matches[r][c]) {
            cleared++;
            board[r][c] = null;
            const tile = getTileEl(r, c);
            if (tile) tile.classList.add("match");
          }
        }
      }
      return cleared;
    }

    function dropTiles() {
      for (let c = 0; c < cols; c++) {
        let pointer = rows - 1;
        for (let r = rows - 1; r >= 0; r--) {
          if (board[r][c] !== null) {
            board[pointer][c] = board[r][c];
            if (pointer !== r) board[r][c] = null;
            pointer--;
          }
        }
        for (let r = pointer; r >= 0; r--) {
          board[r][c] = randColor();
        }
      }
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function resolveBoard() {
      let chain = 0;
      while (true) {
        const { matches, found } = findMatches();
        if (!found) break;
        chain++;
        const cleared = applyMatches(matches);
        score += cleared * 20 * chain;
        updateStats();
        await delay(180);
        dropTiles();
        renderBoard();
        await delay(120);
      }
    }

    async function trySwap(a, b) {
      if (busy) return;
      if (!isAdjacent(a, b)) return;
      busy = true;
      swap(a, b);
      renderBoard();
      await delay(120);
      const { found } = findMatches();
      if (!found) {
        swap(a, b);
        renderBoard();
        await delay(120);
        busy = false;
        return;
      }
      moves--;
      updateStats();
      await resolveBoard();
      checkGame();
      busy = false;
    }

    function checkGame() {
      if (score >= target) {
        setMessage("太棒了！目标完成！");
      } else if (moves <= 0) {
        setMessage("本局结束，再来一次吧！");
      } else {
        setMessage("");
      }
    }

    function resetGame() {
      score = 0;
      applyDifficulty();
      updateStats();
      setMessage("");
      fillBoard();
      renderBoard();
    }

    function shuffleBoard() {
      if (busy) return;
      let attempts = 0;
      do {
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            board[r][c] = randColor();
          }
        }
        attempts++;
      } while (attempts < 10 && findMatches().found);
      renderBoard();
      setMessage("已洗牌");
    }

    function tileFromPoint(x, y) {
      const el = document.elementFromPoint(x, y);
      const tile = el ? el.closest(".tile") : null;
      if (!tile) return null;
      return { r: Number(tile.dataset.row), c: Number(tile.dataset.col), el: tile };
    }

    async function handleTapSwap(target) {
      if (!selected) {
        selected = { r: target.r, c: target.c };
        target.el.classList.add("selected");
        return;
      }
      if (selected.r === target.r && selected.c === target.c) {
        clearSelection();
        return;
      }
      const prev = selected;
      clearSelection();
      await trySwap(prev, { r: target.r, c: target.c });
    }

    boardEl.addEventListener("pointerdown", (event) => {
      if (busy || moves <= 0) return;
      const target = tileFromPoint(event.clientX, event.clientY);
      if (!target) return;
      pointerId = event.pointerId;
      dragStart = { x: event.clientX, y: event.clientY };
      swapTriggered = false;
      boardEl.setPointerCapture(pointerId);
      handleTapSwap(target);
    });

    boardEl.addEventListener("pointermove", async (event) => {
      if (busy || moves <= 0 || pointerId !== event.pointerId || !selected) return;
      const dx = event.clientX - dragStart.x;
      const dy = event.clientY - dragStart.y;
      const dist = Math.hypot(dx, dy);
      if (dist < 8 || swapTriggered) return;
      const target = tileFromPoint(event.clientX, event.clientY);
      if (!target) return;
      if (!isAdjacent(selected, target)) return;
      swapTriggered = true;
      const prev = selected;
      clearSelection();
      await trySwap(prev, { r: target.r, c: target.c });
    });

    boardEl.addEventListener("pointerup", (event) => {
      if (pointerId === event.pointerId) {
        pointerId = null;
        dragStart = null;
      }
    });

    boardEl.addEventListener("pointercancel", () => {
      pointerId = null;
      dragStart = null;
      clearSelection();
    });

    document.getElementById("restart").addEventListener("click", () => {
      resetGame();
    });

    document.getElementById("shuffle").addEventListener("click", () => {
      shuffleBoard();
    });

    document.getElementById("help").addEventListener("click", () => {
      tipsEl.textContent = "玩法：点击或拖动相邻方块交换，三连即可消除。每次交换消耗一步，连锁消除会有额外加分。";
    });

    document.getElementById("difficulty").addEventListener("change", () => {
      resetGame();
    });

    resetGame();
  </script>
</body>
</html>
